## 题目精简后，本质是什么问题

这是一个经典的猜大小游戏，答案 F 在 0 到 N 之间。

每次行动，你可以猜一个数字 X ，会反馈给你“大了”（X > F）、“小了”（X < F）或者“对了”（X == F）。

你的目标是猜中 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小行动次数是多少？



这个游戏大家应该很熟悉吧，翻译成口语。

**“猜大小游戏，如果范围是 1 到 N ，最多猜几次能猜到？”**



## 题目的问题是什么，到底要求什么

按照题目的流程来正面思考的思路应该是：

先从1到N中间的数猜，判断大了还是小了，再去对应的区间继续猜。

最坏的情况，就是每次不是大了就是小了，直到最后才猜中。

举个例子：

比如范围0~2，那么第一次猜1，根据反馈> < ==，就可以确定是0是1还是2。答案是1次。

范围0~3，第一次猜1，只能确定0和1了，如果返回是<，就有2和3还需要再次确定。答案是2次。

范围不断增加，0~4，0~5，0~6，答案都是2次。

范围增加到0~7，答案升到3次。



换一种说法，通过1次尝试，就可以确定的范围是0~2。2次尝试，范围可以达到0~6。

那么，问题就可以变成，**“猜大小游戏，猜几次确定的范围可以将 N 包含在内？”**



## 那么“猜大小”和“鸡蛋掉落”有什么区别

1. 你必须有鸡蛋 （K > 0）才可以猜。
2. 每次行动，你可以猜一个数字 X ，反馈的值只有“鸡蛋碎了”（X >= F）和“鸡蛋没碎”（X < F）。
3. 如果“鸡蛋碎了”，鸡蛋减少1（K = K - 1）。

带来的影响：

1. 如果你的鸡蛋只剩下1个，那么你将告别从中间扔鸡蛋的方法，只能每次从最低的楼层一层一层往上排除，用来保证鸡蛋碎了的时候更低的楼层都测试过，将X >= F变成X == F。

   即：如果你只有1个鸡蛋，你测试T次，范围只能覆盖T + 1层。

2. 即便你的测试X == F，返回的也是X >= F，让你无法直接确认。

   即：如果你只有1次机会，不管你有几个鸡蛋，范围只能覆盖2层。（猜大小的话范围能覆盖3层）

3. 记得代码里“鸡蛋没碎”那边是K，“鸡蛋碎了”那边是K - 1。



## 递归求解，几次机会几个鸡蛋可以确定多大范围

``` C++
int calcMaxN(int T, int K)  // 有K个蛋，T，计算能判断多少层
{
	if (T == 1) return 2;		// 如果只有1次行动了，无论有几个蛋，都只能判断出2层
	if (K == 1) return T + 1;	// 如果只有1个蛋了，蛋不能碎，只能一层一层判断，可以判断出T + 1层

	// 行动一次，扔个蛋，计算蛋碎了的情况下能判断多少层 + 蛋没碎的情况能判断多少层
	return calcMaxN(T - 1, K - 1) + calcMaxN(T - 1, K);
}

int superEggDrop(int K, int N)
{
	int T = 1;
	while (calcMaxN(T, K) < N + 1)
	{
		T++;
	}
	return T;
}
```

